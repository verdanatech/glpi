{"version":3,"file":"jquery-file-upload.js","mappings":";;;;;;AAAA,iVAAiV,iBAAiB,qDAAqD,sGAAsG,MAAM,uCAAuC,8FAA8F,MAAM,MAAM,sDAAsD,KAAK,GAAG,gBAAgB,iBAAiB,8kBAA8kB,mbAAmb,wDAAwD,yNAAyN,6GAA6G,QAAQ,gCAAgC,UAAU,sDAAsD,2CAA2C,2BAA2B,yEAAyE,0CAA0C,6IAA6I,mBAAmB,uBAAuB,6BAA6B,2BAA2B,6CAA6C,WAAW,SAAS,QAAQ,KAAK,slBAAslB,gBAAgB,kvJAAkvJ,8CAA8C,iQAAiQ,mEAAmE,qLAAqL,wHAAwH,wBAAwB,mDAAmD,qGAAqG,YAAY,UAAU,aAAa,EAAE,WAAW,yBAAyB,SAAS,6ZAA6Z,uCAAuC,SAAS,suBAAsuB,6MAA6M,iCAAiC,uCAAuC,yBAAyB,WAAW,2JAA2J,6CAA6C,4BAA4B,aAAa,EAAE,WAAW,SAAS,qIAAqI,mCAAmC,sGAAsG,iCAAiC,mFAAmF,iCAAiC,gGAAgG,iCAAiC,+GAA+G,mCAAmC,2FAA2F,qCAAqC,qGAAqG,wCAAwC,mHAAmH,kCAAkC,gHAAgH,iCAAiC,oGAAoG,mCAAmC,kGAAkG,kCAAkC,+FAA+F,iCAAiC,iGAAiG,qCAAqC,uJAAuJ,4CAA4C,4GAA4G,sCAAsC,8FAA8F,sCAAsC,2GAA2G,sCAAsC,iIAAiI,wCAAwC,mQAAmQ,gXAAgX,2CAA2C,8EAA8E,OAAO,2UAA2U,sEAAsE,8CAA8C,SAAS,qCAAqC,sEAAsE,wBAAwB,yBAAyB,4DAA4D,8CAA8C,kEAAkE,0EAA0E,iCAAiC,iCAAiC,WAAW,8BAA8B,UAAU,OAAO,2CAA2C,6KAA6K,OAAO,2CAA2C,qBAAqB,sDAAsD,gDAAgD,SAAS,0CAA0C,kCAAkC,SAAS,oDAAoD,wBAAwB,2DAA2D,4BAA4B,0BAA0B,EAAE,WAAW,EAAE,0BAA0B,SAAS,kBAAkB,OAAO,sCAAsC,sBAAsB,8CAA8C,kCAAkC,SAAS,EAAE,qBAAqB,OAAO,8CAA8C,wBAAwB,qEAAqE,4BAA4B,4CAA4C,UAAU,MAAM,mCAAmC,SAAS,OAAO,8CAA8C,iBAAiB,4BAA4B,uCAAuC,4EAA4E,yCAAyC,aAAa,WAAW,UAAU,MAAM,6BAA6B,SAAS,OAAO,0CAA0C,iCAAiC,oFAAoF,+KAA+K,mBAAmB,WAAW,2BAA2B,gKAAgK,4KAA4K,+JAA+J,uDAAuD,+JAA+J,iRAAiR,mBAAmB,8BAA8B,sOAAsO,mBAAmB,wCAAwC,SAAS,OAAO,oDAAoD,2FAA2F,gJAAgJ,qDAAqD,qCAAqC,4HAA4H,iCAAiC,+BAA+B,yCAAyC,WAAW,EAAE,qCAAqC,uBAAuB,YAAY,SAAS,OAAO,sDAAsD,qEAAqE,yBAAyB,wCAAwC,SAAS,OAAO,8CAA8C,sHAAsH,OAAO,mDAAmD,iFAAiF,wBAAwB,2LAA2L,gDAAgD,+BAA+B,4CAA4C,WAAW,EAAE,oDAAoD,SAAS,yBAAyB,oBAAoB,OAAO,2CAA2C,wVAAwV,qCAAqC,mBAAmB,mCAAmC,kEAAkE,SAAS,8EAA8E,2EAA2E,oFAAoF,SAAS,yBAAyB,wEAAwE,8CAA8C,UAAU,2CAA2C,oCAAoC,8SAA8S,+BAA+B,6BAA6B,kFAAkF,EAAE,cAAc,MAAM,4DAA4D,+BAA+B,kNAAkN,EAAE,eAAe,EAAE,aAAa,YAAY,MAAM,mEAAmE,0CAA0C,cAAc,MAAM,wCAAwC,0EAA0E,yDAAyD,eAAe,EAAE,aAAa,+BAA+B,iJAAiJ,cAAc,MAAM,4DAA4D,yOAAyO,8DAA8D,gDAAgD,yJAAyJ,mBAAmB,0PAA0P,iBAAiB,eAAe,EAAE,aAAa,WAAW,kCAAkC,SAAS,yFAAyF,OAAO,kDAAkD,6EAA6E,uIAAuI,8HAA8H,8IAA8I,iCAAiC,wGAAwG,EAAE,SAAS,OAAO,gDAAgD,yCAAyC,oDAAoD,gCAAgC,yCAAyC,aAAa,gDAAgD,WAAW,oCAAoC,4KAA4K,WAAW,UAAU,MAAM,4CAA4C,SAAS,OAAO,4CAA4C,qFAAqF,yBAAyB,yBAAyB,sCAAsC,2IAA2I,uBAAuB,mCAAmC,qBAAqB,aAAa,WAAW,EAAE,kCAAkC,8DAA8D,WAAW,UAAU,iCAAiC,kCAAkC,SAAS,yBAAyB,OAAO,gDAAgD,6JAA6J,2DAA2D,gKAAgK,kEAAkE,WAAW,SAAS,wDAAwD,2BAA2B,qEAAqE,SAAS,6PAA6P,gIAAgI,gCAAgC,SAAS,yCAAyC,0EAA0E,SAAS,OAAO,4CAA4C,iCAAiC,sBAAsB,wCAAwC,wCAAwC,uBAAuB,OAAO,iKAAiK,6BAA6B,kCAAkC,SAAS,oCAAoC,4BAA4B,SAAS,oCAAoC,4BAA4B,SAAS,yBAAyB,OAAO,0IAA0I,uCAAuC,qCAAqC,0CAA0C,uBAAuB,OAAO,6LAA6L,iEAAiE,kHAAkH,uCAAuC,yCAAyC,UAAU,qCAAqC,wCAAwC,SAAS,oCAAoC,6CAA6C,OAAO,qHAAqH,gEAAgE,kEAAkE,YAAY,2DAA2D,0CAA0C,4JAA4J,uCAAuC,yEAAyE,iBAAiB,6CAA6C,eAAe,4DAA4D,WAAW,0DAA0D,UAAU,mCAAmC,2CAA2C,8HAA8H,mBAAmB,yEAAyE,WAAW,qDAAqD,UAAU,kCAAkC,2BAA2B,sCAAsC,WAAW,qCAAqC,4CAA4C,4CAA4C,UAAU,kCAAkC,2BAA2B,sDAAsD,WAAW,mCAAmC,8DAA8D,WAAW,UAAU,uCAAuC,6JAA6J,UAAU,qCAAqC,gCAAgC,UAAU,qCAAqC,gCAAgC,UAAU,OAAO,+IAA+I,+KAA+K,kDAAkD,OAAO,gUAAgU,2DAA2D,qSAAqS,8MAA8M,uBAAuB,SAAS,uBAAuB,sBAAsB,SAAS,uBAAuB,qDAAqD,sIAAsI,SAAS,iEAAiE,yFAAyF,0DAA0D,4JAA4J,yJAAyJ,iJAAiJ,wIAAwI,uGAAuG,kGAAkG,kNAAkN,qEAAqE,sOAAsO,wEAAwE,8JAA8J,uCAAuC,eAAe,2DAA2D,gCAAgC,wCAAwC,8BAA8B,kDAAkD,oDAAoD,4BAA4B,yHAAyH,gBAAgB,MAAM,wEAAwE,eAAe,aAAa,8DAA8D,8BAA8B,wCAAwC,0CAA0C,kDAAkD,oDAAoD,0EAA0E,aAAa,kCAAkC,8CAA8C,aAAa,EAAE,UAAU,sCAAsC,qCAAqC,+BAA+B,UAAU,iBAAiB,uBAAuB,OAAO,0CAA0C,iCAAiC,iNAAiN,uHAAuH,yGAAyG,qCAAqC,SAAS,oNAAoN,uCAAuC,sEAAsE,4EAA4E,kDAAkD,0BAA0B,8FAA8F,2CAA2C,OAAO,iEAAiE,mFAAmF,+CAA+C,sLAAsL,wGAAwG,iCAAiC,SAAS,kDAAkD,8DAA8D,+CAA+C,6CAA6C,OAAO,sEAAsE,yCAAyC,0CAA0C,yKAAyK,0DAA0D,SAAS,+CAA+C,8DAA8D,iEAAiE,6CAA6C,OAAO,iFAAiF,0KAA0K,OAAO,sCAAsC,2BAA2B,+CAA+C,SAAS,sKAAsK,+BAA+B,uHAAuH,qLAAqL,mBAAmB,iSAAiS,mEAAmE,iBAAiB,kEAAkE,wEAAwE,iBAAiB,6EAA6E,wDAAwD,kLAAkL,qCAAqC,oCAAoC,kKAAkK,4JAA4J,sCAAsC,2EAA2E,2CAA2C,8BAA8B,uBAAuB,qDAAqD,qBAAqB,mBAAmB,2CAA2C,oMAAoM,mBAAmB,iBAAiB,EAAE,yBAAyB,YAAY,qCAAqC,oLAAoL,wDAAwD,gCAAgC,mCAAmC,iDAAiD,YAAY,MAAM,2EAA2E,kCAAkC,WAAW,oQAAoQ,oDAAoD,yBAAyB,yBAAyB,0DAA0D,eAAe,4BAA4B,aAAa,iCAAiC,YAAY,4CAA4C,SAAS,sBAAsB,OAAO,qCAAqC,+EAA+E,qaAAqa,2BAA2B,uBAAuB,SAAS,uDAAuD,gCAAgC,SAAS,2HAA2H,4BAA4B,qCAAqC,UAAU,8DAA8D,uBAAuB,4BAA4B,sBAAsB,iBAAiB,aAAa,oDAAoD,2DAA2D,yCAAyC,yCAAyC,aAAa,8CAA8C,WAAW,UAAU,mDAAmD,uBAAuB,4BAA4B,sBAAsB,iBAAiB,YAAY,kDAAkD,qLAAqL,kDAAkD,yDAAyD,2CAA2C,2CAA2C,eAAe,gDAAgD,wBAAwB,4BAA4B,aAAa,WAAW,UAAU,MAAM,mCAAmC,SAAS,mCAAmC,4DAA4D,mCAAmC,QAAQ,wDAAwD,kDAAkD,4CAA4C,4CAA4C,kDAAkD,gFAAgF,mBAAmB,iCAAiC,wBAAwB,SAAS,EAAE,sBAAsB,OAAO,6CAA6C,sIAAsI,uHAAuH,yDAAyD,4JAA4J,mIAAmI,sCAAsC,SAAS,oGAAoG,kPAAkP,gCAAgC,iCAAiC,WAAW,oBAAoB,SAAS,EAAE,6KAA6K,oCAAoC,SAAS,OAAO,uDAAuD,uIAAuI,gCAAgC,8BAA8B,aAAa,yPAAyP,WAAW,gDAAgD,6HAA6H,mCAAmC,eAAe,mCAAmC,WAAW,sCAAsC,sDAAsD,oCAAoC,wCAAwC,gBAAgB,MAAM,kDAAkD,8BAA8B,eAAe,aAAa,gBAAgB,YAAY,+EAA+E,2BAA2B,4BAA4B,4FAA4F,qCAAqC,YAAY,MAAM,wCAAwC,uCAAuC,gCAAgC,aAAa,gBAAgB,WAAW,UAAU,6BAA6B,2CAA2C,wBAAwB,UAAU,MAAM,8HAA8H,SAAS,6BAA6B,OAAO,2DAA2D,wBAAwB,iGAAiG,4DAA4D,aAAa,uDAAuD,+DAA+D,WAAW,EAAE,OAAO,oDAAoD,+FAA+F,uCAAuC,8HAA8H,uFAAuF,wBAAwB,0CAA0C,gDAAgD,4BAA4B,wGAAwG,iBAAiB,6BAA6B,eAAe,uCAAuC,aAAa,aAAa,SAAS,+EAA+E,OAAO,yDAAyD,sFAAsF,8HAA8H,wCAAwC,sDAAsD,SAAS,qDAAqD,4BAA4B,0CAA0C,uBAAuB,sDAAsD,WAAW,uOAAuO,oCAAoC,EAAE,UAAU,4DAA4D,2GAA2G,sCAAsC,sCAAsC,WAAW,EAAE,SAAS,qDAAqD,OAAO,mDAAmD,kEAAkE,0DAA0D,SAAS,oIAAoI,+DAA+D,WAAW,EAAE,OAAO,kCAAkC,0CAA0C,iFAAiF,yEAAyE,6BAA6B,8CAA8C,yCAAyC,WAAW,iGAAiG,mBAAmB,wDAAwD,iCAAiC,WAAW,SAAS,EAAE,OAAO,iCAAiC,gKAAgK,YAAY,oCAAoC,gDAAgD,0DAA0D,uBAAuB,oCAAoC,aAAa,WAAW,EAAE,+FAA+F,mBAAmB,wDAAwD,iCAAiC,WAAW,SAAS,OAAO,gCAAgC,yEAAyE,oFAAoF,8EAA8E,6BAA6B,uEAAuE,+BAA+B,qGAAqG,mBAAmB,8DAA8D,mCAAmC,aAAa,WAAW,EAAE,SAAS,OAAO,8LAA8L,8CAA8C,2CAA2C,gTAAgT,EAAE,4CAA4C,2CAA2C,EAAE,SAAS,kCAAkC,4CAA4C,6CAA6C,EAAE,SAAS,OAAO,6CAA6C,8EAA8E,mDAAmD,oDAAoD,OAAO,gCAAgC,qCAAqC,OAAO,4CAA4C,iEAAiE,qBAAqB,uCAAuC,SAAS,gCAAgC,qBAAqB,qCAAqC,oCAAoC,SAAS,OAAO,2CAA2C,mCAAmC,8CAA8C,uJAAuJ,UAAU,6CAA6C,mDAAmD,SAAS,+CAA+C,iDAAiD,SAAS,gDAAgD,mDAAmD,SAAS,OAAO,qCAAqC,qEAAqE,sBAAsB,sDAAsD,OAAO,iDAAiD,2GAA2G,IAAI,wBAAwB,OAAO,2CAA2C,8FAA8F,+HAA+H,8DAA8D,mCAAmC,sHAAsH,iDAAiD,aAAa,EAAE,8BAA8B,mDAAmD,6CAA6C,aAAa,iCAAiC,WAAW,SAAS,EAAE,OAAO,+BAA+B,mCAAmC,mCAAmC,yBAAyB,mDAAmD,yCAAyC,uCAAuC,kCAAkC,OAAO,yIAAyI,4BAA4B,OAAO,iPAAiP,8BAA8B,OAAO,6PAA6P,iBAAiB,EAAE,4BAA4B,wBAAwB,6CAA6C,iBAAiB,SAAS,4CAA4C,2EAA2E,+BAA+B,oCAAoC,WAAW,EAAE,UAAU,MAAM,+CAA+C,kCAAkC,SAAS,OAAO,4QAA4Q,iBAAiB,EAAE,mGAAmG,6CAA6C,8CAA8C,6IAA6I,yCAAyC,6BAA6B,0BAA0B,qCAAqC,eAAe,iDAAiD,6BAA6B,cAAc,6EAA6E,4BAA4B,uBAAuB,eAAe,kCAAkC,6BAA6B,uBAAuB,eAAe,iCAAiC,+CAA+C,+EAA+E,yDAAyD,iBAAiB,4DAA4D,6DAA6D,iBAAiB,gBAAgB,aAAa,EAAE,iDAAiD,WAAW,+CAA+C,kCAAkC,4CAA4C,WAAW,SAAS,gEAAgE,OAAO,KAAK,EAAE,GAAG,EAAE;;;;;;;ACAl/xD,wTAAwT,iBAAiB,qDAAqD,+EAA+E,MAAM,uCAAuC,wDAAwD,MAAM,MAAM,sDAAsD,KAAK,GAAG,gBAAgB,iBAAiB,8IAA8I,gDAAgD,qBAAqB,0BAA0B,KAAK,ycAAyc,oBAAoB,GAAG,oBAAoB,iHAAiH,oDAAoD,0BAA0B,kOAAkO,yDAAyD,gBAAgB,gDAAgD,iDAAiD,aAAa,mEAAmE,+DAA+D,qGAAqG,0EAA0E,oCAAoC,cAAc,kCAAkC,uEAAuE,oCAAoC,cAAc,oCAAoC,yEAAyE,oCAAoC,aAAa,iOAAiO,qOAAqO,wKAAwK,yDAAyD,6BAA6B,kKAAkK,+CAA+C,uQAAuQ,sCAAsC,mBAAmB,kBAAkB,WAAW,uCAAuC,iBAAiB,qKAAqK,kBAAkB,EAAE,uPAAuP,+CAA+C,kMAAkM,iBAAiB,KAAK,eAAe,EAAE,gKAAgK,qCAAqC,kEAAkE,qKAAqK,iBAAiB,EAAE,eAAe,yJAAyJ,4DAA4D,sHAAsH,gDAAgD,iBAAiB,EAAE,wCAAwC,2DAA2D,iFAAiF,mBAAmB,EAAE,iBAAiB,kXAAkX,0HAA0H,eAAe,6CAA6C,8TAA8T,wMAAwM,kEAAkE,0DAA0D,gNAAgN,6CAA6C,mBAAmB,EAAE,iBAAiB,eAAe,KAAK,aAAa,EAAE,wDAAwD,WAAW,+BAA+B,yBAAyB,8LAA8L,aAAa,uBAAuB,4BAA4B,aAAa,WAAW,UAAU,OAAO,KAAK,EAAE,6oBAA6oB,mBAAmB,0CAA0C,oDAAoD,SAAS,2CAA2C,wEAAwE,SAAS,2CAA2C,oDAAoD,SAAS,0CAA0C,2CAA2C,kNAAkN,SAAS,6CAA6C,kEAAkE,SAAS,OAAO,KAAK,EAAE,GAAG,EAAE;;;;;;;ACA99R;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;AC1BA,mBAAO,CAAC,CAAiE,EAAE,mBAAO,CAAC,GAA6M;;;;;;;ACAhS,mBAAO,CAAC,CAAiE,EAAE,mBAAO,CAAC,GAAmN;;;;;;UCAtS;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,iCAAiC;AACjC;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAO,CAAC,GAA8D;AACtE,mBAAO,CAAC,GAAoE","sources":["webpack://@glpi/glpi/./vendor/blueimp/jquery-file-upload/js/jquery.fileupload.js","webpack://@glpi/glpi/./vendor/blueimp/jquery-file-upload/js/jquery.iframe-transport.js","webpack://@glpi/glpi/./node_modules/script-loader/addScript.js","webpack://@glpi/glpi/./vendor/blueimp/jquery-file-upload/js/jquery.fileupload.js?6f32","webpack://@glpi/glpi/./vendor/blueimp/jquery-file-upload/js/jquery.iframe-transport.js?dbb0","webpack://@glpi/glpi/webpack/bootstrap","webpack://@glpi/glpi/./lib/bundles/jquery-file-upload.js"],"sourcesContent":["module.exports = \"/*\\n * jQuery File Upload Plugin\\n * https://github.com/blueimp/jQuery-File-Upload\\n *\\n * Copyright 2010, Sebastian Tschan\\n * https://blueimp.net\\n *\\n * Licensed under the MIT license:\\n * https://opensource.org/licenses/MIT\\n */\\n\\n/* global define, require */\\n/* eslint-disable new-cap */\\n\\n(function (factory) {\\n  'use strict';\\n  if (typeof define === 'function' && define.amd) {\\n    // Register as an anonymous AMD module:\\n    define(['jquery', 'jquery-ui/ui/widget'], factory);\\n  } else if (typeof exports === 'object') {\\n    // Node/CommonJS:\\n    factory(require('jquery'), require('./vendor/jquery.ui.widget'));\\n  } else {\\n    // Browser globals:\\n    factory(window.jQuery);\\n  }\\n})(function ($) {\\n  'use strict';\\n\\n  // Detect file input support, based on\\n  // https://viljamis.com/2012/file-upload-support-on-mobile/\\n  $.support.fileInput = !(\\n    new RegExp(\\n      // Handle devices which give false positives for the feature detection:\\n      '(Android (1\\\\\\\\.[0156]|2\\\\\\\\.[01]))' +\\n        '|(Windows Phone (OS 7|8\\\\\\\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' +\\n        '|(w(eb)?OSBrowser)|(webOS)' +\\n        '|(Kindle/(1\\\\\\\\.0|2\\\\\\\\.[05]|3\\\\\\\\.0))'\\n    ).test(window.navigator.userAgent) ||\\n    // Feature detection for all other devices:\\n    $('<input type=\\\"file\\\"/>').prop('disabled')\\n  );\\n\\n  // The FileReader API is not actually used, but works as feature detection,\\n  // as some Safari versions (5?) support XHR file uploads via the FormData API,\\n  // but not non-multipart XHR file uploads.\\n  // window.XMLHttpRequestUpload is not available on IE10, so we check for\\n  // window.ProgressEvent instead to detect XHR2 file upload capability:\\n  $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);\\n  $.support.xhrFormDataFileUpload = !!window.FormData;\\n\\n  // Detect support for Blob slicing (required for chunked uploads):\\n  $.support.blobSlice =\\n    window.Blob &&\\n    (Blob.prototype.slice ||\\n      Blob.prototype.webkitSlice ||\\n      Blob.prototype.mozSlice);\\n\\n  /**\\n   * Helper function to create drag handlers for dragover/dragenter/dragleave\\n   *\\n   * @param {string} type Event type\\n   * @returns {Function} Drag handler\\n   */\\n  function getDragHandler(type) {\\n    var isDragOver = type === 'dragover';\\n    return function (e) {\\n      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\\n      var dataTransfer = e.dataTransfer;\\n      if (\\n        dataTransfer &&\\n        $.inArray('Files', dataTransfer.types) !== -1 &&\\n        this._trigger(type, $.Event(type, { delegatedEvent: e })) !== false\\n      ) {\\n        e.preventDefault();\\n        if (isDragOver) {\\n          dataTransfer.dropEffect = 'copy';\\n        }\\n      }\\n    };\\n  }\\n\\n  // The fileupload widget listens for change events on file input fields defined\\n  // via fileInput setting and paste or drop events of the given dropZone.\\n  // In addition to the default jQuery Widget methods, the fileupload widget\\n  // exposes the \\\"add\\\" and \\\"send\\\" methods, to add or directly send files using\\n  // the fileupload API.\\n  // By default, files added via file input selection, paste, drag & drop or\\n  // \\\"add\\\" method are uploaded immediately, but it is possible to override\\n  // the \\\"add\\\" callback option to queue file uploads.\\n  $.widget('blueimp.fileupload', {\\n    options: {\\n      // The drop target element(s), by the default the complete document.\\n      // Set to null to disable drag & drop support:\\n      dropZone: $(document),\\n      // The paste target element(s), by the default undefined.\\n      // Set to a DOM node or jQuery object to enable file pasting:\\n      pasteZone: undefined,\\n      // The file input field(s), that are listened to for change events.\\n      // If undefined, it is set to the file input fields inside\\n      // of the widget element on plugin initialization.\\n      // Set to null to disable the change listener.\\n      fileInput: undefined,\\n      // By default, the file input field is replaced with a clone after\\n      // each input field change event. This is required for iframe transport\\n      // queues and allows change events to be fired for the same file\\n      // selection, but can be disabled by setting the following option to false:\\n      replaceFileInput: true,\\n      // The parameter name for the file form data (the request argument name).\\n      // If undefined or empty, the name property of the file input field is\\n      // used, or \\\"files[]\\\" if the file input name property is also empty,\\n      // can be a string or an array of strings:\\n      paramName: undefined,\\n      // By default, each file of a selection is uploaded using an individual\\n      // request for XHR type uploads. Set to false to upload file\\n      // selections in one request each:\\n      singleFileUploads: true,\\n      // To limit the number of files uploaded with one XHR request,\\n      // set the following option to an integer greater than 0:\\n      limitMultiFileUploads: undefined,\\n      // The following option limits the number of files uploaded with one\\n      // XHR request to keep the request size under or equal to the defined\\n      // limit in bytes:\\n      limitMultiFileUploadSize: undefined,\\n      // Multipart file uploads add a number of bytes to each uploaded file,\\n      // therefore the following option adds an overhead for each file used\\n      // in the limitMultiFileUploadSize configuration:\\n      limitMultiFileUploadSizeOverhead: 512,\\n      // Set the following option to true to issue all file upload requests\\n      // in a sequential order:\\n      sequentialUploads: false,\\n      // To limit the number of concurrent uploads,\\n      // set the following option to an integer greater than 0:\\n      limitConcurrentUploads: undefined,\\n      // Set the following option to true to force iframe transport uploads:\\n      forceIframeTransport: false,\\n      // Set the following option to the location of a redirect url on the\\n      // origin server, for cross-domain iframe transport uploads:\\n      redirect: undefined,\\n      // The parameter name for the redirect url, sent as part of the form\\n      // data and set to 'redirect' if this option is empty:\\n      redirectParamName: undefined,\\n      // Set the following option to the location of a postMessage window,\\n      // to enable postMessage transport uploads:\\n      postMessage: undefined,\\n      // By default, XHR file uploads are sent as multipart/form-data.\\n      // The iframe transport is always using multipart/form-data.\\n      // Set to false to enable non-multipart XHR uploads:\\n      multipart: true,\\n      // To upload large files in smaller chunks, set the following option\\n      // to a preferred maximum chunk size. If set to 0, null or undefined,\\n      // or the browser does not support the required Blob API, files will\\n      // be uploaded as a whole.\\n      maxChunkSize: undefined,\\n      // When a non-multipart upload or a chunked multipart upload has been\\n      // aborted, this option can be used to resume the upload by setting\\n      // it to the size of the already uploaded bytes. This option is most\\n      // useful when modifying the options object inside of the \\\"add\\\" or\\n      // \\\"send\\\" callbacks, as the options are cloned for each file upload.\\n      uploadedBytes: undefined,\\n      // By default, failed (abort or error) file uploads are removed from the\\n      // global progress calculation. Set the following option to false to\\n      // prevent recalculating the global progress data:\\n      recalculateProgress: true,\\n      // Interval in milliseconds to calculate and trigger progress events:\\n      progressInterval: 100,\\n      // Interval in milliseconds to calculate progress bitrate:\\n      bitrateInterval: 500,\\n      // By default, uploads are started automatically when adding files:\\n      autoUpload: true,\\n      // By default, duplicate file names are expected to be handled on\\n      // the server-side. If this is not possible (e.g. when uploading\\n      // files directly to Amazon S3), the following option can be set to\\n      // an empty object or an object mapping existing filenames, e.g.:\\n      // { \\\"image.jpg\\\": true, \\\"image (1).jpg\\\": true }\\n      // If it is set, all files will be uploaded with unique filenames,\\n      // adding increasing number suffixes if necessary, e.g.:\\n      // \\\"image (2).jpg\\\"\\n      uniqueFilenames: undefined,\\n\\n      // Error and info messages:\\n      messages: {\\n        uploadedBytes: 'Uploaded bytes exceed file size'\\n      },\\n\\n      // Translation function, gets the message key to be translated\\n      // and an object with context specific data as arguments:\\n      i18n: function (message, context) {\\n        // eslint-disable-next-line no-param-reassign\\n        message = this.messages[message] || message.toString();\\n        if (context) {\\n          $.each(context, function (key, value) {\\n            // eslint-disable-next-line no-param-reassign\\n            message = message.replace('{' + key + '}', value);\\n          });\\n        }\\n        return message;\\n      },\\n\\n      // Additional form data to be sent along with the file uploads can be set\\n      // using this option, which accepts an array of objects with name and\\n      // value properties, a function returning such an array, a FormData\\n      // object (for XHR file uploads), or a simple object.\\n      // The form of the first fileInput is given as parameter to the function:\\n      formData: function (form) {\\n        return form.serializeArray();\\n      },\\n\\n      // The add callback is invoked as soon as files are added to the fileupload\\n      // widget (via file input selection, drag & drop, paste or add API call).\\n      // If the singleFileUploads option is enabled, this callback will be\\n      // called once for each file in the selection for XHR file uploads, else\\n      // once for each file selection.\\n      //\\n      // The upload starts when the submit method is invoked on the data parameter.\\n      // The data object contains a files property holding the added files\\n      // and allows you to override plugin options as well as define ajax settings.\\n      //\\n      // Listeners for this callback can also be bound the following way:\\n      // .on('fileuploadadd', func);\\n      //\\n      // data.submit() returns a Promise object and allows to attach additional\\n      // handlers using jQuery's Deferred callbacks:\\n      // data.submit().done(func).fail(func).always(func);\\n      add: function (e, data) {\\n        if (e.isDefaultPrevented()) {\\n          return false;\\n        }\\n        if (\\n          data.autoUpload ||\\n          (data.autoUpload !== false &&\\n            $(this).fileupload('option', 'autoUpload'))\\n        ) {\\n          data.process().done(function () {\\n            data.submit();\\n          });\\n        }\\n      },\\n\\n      // Other callbacks:\\n\\n      // Callback for the submit event of each file upload:\\n      // submit: function (e, data) {}, // .on('fileuploadsubmit', func);\\n\\n      // Callback for the start of each file upload request:\\n      // send: function (e, data) {}, // .on('fileuploadsend', func);\\n\\n      // Callback for successful uploads:\\n      // done: function (e, data) {}, // .on('fileuploaddone', func);\\n\\n      // Callback for failed (abort or error) uploads:\\n      // fail: function (e, data) {}, // .on('fileuploadfail', func);\\n\\n      // Callback for completed (success, abort or error) requests:\\n      // always: function (e, data) {}, // .on('fileuploadalways', func);\\n\\n      // Callback for upload progress events:\\n      // progress: function (e, data) {}, // .on('fileuploadprogress', func);\\n\\n      // Callback for global upload progress events:\\n      // progressall: function (e, data) {}, // .on('fileuploadprogressall', func);\\n\\n      // Callback for uploads start, equivalent to the global ajaxStart event:\\n      // start: function (e) {}, // .on('fileuploadstart', func);\\n\\n      // Callback for uploads stop, equivalent to the global ajaxStop event:\\n      // stop: function (e) {}, // .on('fileuploadstop', func);\\n\\n      // Callback for change events of the fileInput(s):\\n      // change: function (e, data) {}, // .on('fileuploadchange', func);\\n\\n      // Callback for paste events to the pasteZone(s):\\n      // paste: function (e, data) {}, // .on('fileuploadpaste', func);\\n\\n      // Callback for drop events of the dropZone(s):\\n      // drop: function (e, data) {}, // .on('fileuploaddrop', func);\\n\\n      // Callback for dragover events of the dropZone(s):\\n      // dragover: function (e) {}, // .on('fileuploaddragover', func);\\n\\n      // Callback before the start of each chunk upload request (before form data initialization):\\n      // chunkbeforesend: function (e, data) {}, // .on('fileuploadchunkbeforesend', func);\\n\\n      // Callback for the start of each chunk upload request:\\n      // chunksend: function (e, data) {}, // .on('fileuploadchunksend', func);\\n\\n      // Callback for successful chunk uploads:\\n      // chunkdone: function (e, data) {}, // .on('fileuploadchunkdone', func);\\n\\n      // Callback for failed (abort or error) chunk uploads:\\n      // chunkfail: function (e, data) {}, // .on('fileuploadchunkfail', func);\\n\\n      // Callback for completed (success, abort or error) chunk upload requests:\\n      // chunkalways: function (e, data) {}, // .on('fileuploadchunkalways', func);\\n\\n      // The plugin options are used as settings object for the ajax calls.\\n      // The following are jQuery ajax settings required for the file uploads:\\n      processData: false,\\n      contentType: false,\\n      cache: false,\\n      timeout: 0\\n    },\\n\\n    // jQuery versions before 1.8 require promise.pipe if the return value is\\n    // used, as promise.then in older versions has a different behavior, see:\\n    // https://blog.jquery.com/2012/08/09/jquery-1-8-released/\\n    // https://bugs.jquery.com/ticket/11010\\n    // https://github.com/blueimp/jQuery-File-Upload/pull/3435\\n    _promisePipe: (function () {\\n      var parts = $.fn.jquery.split('.');\\n      return Number(parts[0]) > 1 || Number(parts[1]) > 7 ? 'then' : 'pipe';\\n    })(),\\n\\n    // A list of options that require reinitializing event listeners and/or\\n    // special initialization code:\\n    _specialOptions: [\\n      'fileInput',\\n      'dropZone',\\n      'pasteZone',\\n      'multipart',\\n      'forceIframeTransport'\\n    ],\\n\\n    _blobSlice:\\n      $.support.blobSlice &&\\n      function () {\\n        var slice = this.slice || this.webkitSlice || this.mozSlice;\\n        return slice.apply(this, arguments);\\n      },\\n\\n    _BitrateTimer: function () {\\n      this.timestamp = Date.now ? Date.now() : new Date().getTime();\\n      this.loaded = 0;\\n      this.bitrate = 0;\\n      this.getBitrate = function (now, loaded, interval) {\\n        var timeDiff = now - this.timestamp;\\n        if (!this.bitrate || !interval || timeDiff > interval) {\\n          this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\\n          this.loaded = loaded;\\n          this.timestamp = now;\\n        }\\n        return this.bitrate;\\n      };\\n    },\\n\\n    _isXHRUpload: function (options) {\\n      return (\\n        !options.forceIframeTransport &&\\n        ((!options.multipart && $.support.xhrFileUpload) ||\\n          $.support.xhrFormDataFileUpload)\\n      );\\n    },\\n\\n    _getFormData: function (options) {\\n      var formData;\\n      if ($.type(options.formData) === 'function') {\\n        return options.formData(options.form);\\n      }\\n      if ($.isArray(options.formData)) {\\n        return options.formData;\\n      }\\n      if ($.type(options.formData) === 'object') {\\n        formData = [];\\n        $.each(options.formData, function (name, value) {\\n          formData.push({ name: name, value: value });\\n        });\\n        return formData;\\n      }\\n      return [];\\n    },\\n\\n    _getTotal: function (files) {\\n      var total = 0;\\n      $.each(files, function (index, file) {\\n        total += file.size || 1;\\n      });\\n      return total;\\n    },\\n\\n    _initProgressObject: function (obj) {\\n      var progress = {\\n        loaded: 0,\\n        total: 0,\\n        bitrate: 0\\n      };\\n      if (obj._progress) {\\n        $.extend(obj._progress, progress);\\n      } else {\\n        obj._progress = progress;\\n      }\\n    },\\n\\n    _initResponseObject: function (obj) {\\n      var prop;\\n      if (obj._response) {\\n        for (prop in obj._response) {\\n          if (Object.prototype.hasOwnProperty.call(obj._response, prop)) {\\n            delete obj._response[prop];\\n          }\\n        }\\n      } else {\\n        obj._response = {};\\n      }\\n    },\\n\\n    _onProgress: function (e, data) {\\n      if (e.lengthComputable) {\\n        var now = Date.now ? Date.now() : new Date().getTime(),\\n          loaded;\\n        if (\\n          data._time &&\\n          data.progressInterval &&\\n          now - data._time < data.progressInterval &&\\n          e.loaded !== e.total\\n        ) {\\n          return;\\n        }\\n        data._time = now;\\n        loaded =\\n          Math.floor(\\n            (e.loaded / e.total) * (data.chunkSize || data._progress.total)\\n          ) + (data.uploadedBytes || 0);\\n        // Add the difference from the previously loaded state\\n        // to the global loaded counter:\\n        this._progress.loaded += loaded - data._progress.loaded;\\n        this._progress.bitrate = this._bitrateTimer.getBitrate(\\n          now,\\n          this._progress.loaded,\\n          data.bitrateInterval\\n        );\\n        data._progress.loaded = data.loaded = loaded;\\n        data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(\\n          now,\\n          loaded,\\n          data.bitrateInterval\\n        );\\n        // Trigger a custom progress event with a total data property set\\n        // to the file size(s) of the current upload and a loaded data\\n        // property calculated accordingly:\\n        this._trigger(\\n          'progress',\\n          $.Event('progress', { delegatedEvent: e }),\\n          data\\n        );\\n        // Trigger a global progress event for all current file uploads,\\n        // including ajax calls queued for sequential file uploads:\\n        this._trigger(\\n          'progressall',\\n          $.Event('progressall', { delegatedEvent: e }),\\n          this._progress\\n        );\\n      }\\n    },\\n\\n    _initProgressListener: function (options) {\\n      var that = this,\\n        xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\\n      // Accesss to the native XHR object is required to add event listeners\\n      // for the upload progress event:\\n      if (xhr.upload) {\\n        $(xhr.upload).on('progress', function (e) {\\n          var oe = e.originalEvent;\\n          // Make sure the progress event properties get copied over:\\n          e.lengthComputable = oe.lengthComputable;\\n          e.loaded = oe.loaded;\\n          e.total = oe.total;\\n          that._onProgress(e, options);\\n        });\\n        options.xhr = function () {\\n          return xhr;\\n        };\\n      }\\n    },\\n\\n    _deinitProgressListener: function (options) {\\n      var xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\\n      if (xhr.upload) {\\n        $(xhr.upload).off('progress');\\n      }\\n    },\\n\\n    _isInstanceOf: function (type, obj) {\\n      // Cross-frame instanceof check\\n      return Object.prototype.toString.call(obj) === '[object ' + type + ']';\\n    },\\n\\n    _getUniqueFilename: function (name, map) {\\n      // eslint-disable-next-line no-param-reassign\\n      name = String(name);\\n      if (map[name]) {\\n        // eslint-disable-next-line no-param-reassign\\n        name = name.replace(/(?: \\\\(([\\\\d]+)\\\\))?(\\\\.[^.]+)?$/, function (\\n          _,\\n          p1,\\n          p2\\n        ) {\\n          var index = p1 ? Number(p1) + 1 : 1;\\n          var ext = p2 || '';\\n          return ' (' + index + ')' + ext;\\n        });\\n        return this._getUniqueFilename(name, map);\\n      }\\n      map[name] = true;\\n      return name;\\n    },\\n\\n    _initXHRData: function (options) {\\n      var that = this,\\n        formData,\\n        file = options.files[0],\\n        // Ignore non-multipart setting if not supported:\\n        multipart = options.multipart || !$.support.xhrFileUpload,\\n        paramName =\\n          $.type(options.paramName) === 'array'\\n            ? options.paramName[0]\\n            : options.paramName;\\n      options.headers = $.extend({}, options.headers);\\n      if (options.contentRange) {\\n        options.headers['Content-Range'] = options.contentRange;\\n      }\\n      if (!multipart || options.blob || !this._isInstanceOf('File', file)) {\\n        options.headers['Content-Disposition'] =\\n          'attachment; filename=\\\"' +\\n          encodeURI(file.uploadName || file.name) +\\n          '\\\"';\\n      }\\n      if (!multipart) {\\n        options.contentType = file.type || 'application/octet-stream';\\n        options.data = options.blob || file;\\n      } else if ($.support.xhrFormDataFileUpload) {\\n        if (options.postMessage) {\\n          // window.postMessage does not allow sending FormData\\n          // objects, so we just add the File/Blob objects to\\n          // the formData array and let the postMessage window\\n          // create the FormData object out of this array:\\n          formData = this._getFormData(options);\\n          if (options.blob) {\\n            formData.push({\\n              name: paramName,\\n              value: options.blob\\n            });\\n          } else {\\n            $.each(options.files, function (index, file) {\\n              formData.push({\\n                name:\\n                  ($.type(options.paramName) === 'array' &&\\n                    options.paramName[index]) ||\\n                  paramName,\\n                value: file\\n              });\\n            });\\n          }\\n        } else {\\n          if (that._isInstanceOf('FormData', options.formData)) {\\n            formData = options.formData;\\n          } else {\\n            formData = new FormData();\\n            $.each(this._getFormData(options), function (index, field) {\\n              formData.append(field.name, field.value);\\n            });\\n          }\\n          if (options.blob) {\\n            formData.append(\\n              paramName,\\n              options.blob,\\n              file.uploadName || file.name\\n            );\\n          } else {\\n            $.each(options.files, function (index, file) {\\n              // This check allows the tests to run with\\n              // dummy objects:\\n              if (\\n                that._isInstanceOf('File', file) ||\\n                that._isInstanceOf('Blob', file)\\n              ) {\\n                var fileName = file.uploadName || file.name;\\n                if (options.uniqueFilenames) {\\n                  fileName = that._getUniqueFilename(\\n                    fileName,\\n                    options.uniqueFilenames\\n                  );\\n                }\\n                formData.append(\\n                  ($.type(options.paramName) === 'array' &&\\n                    options.paramName[index]) ||\\n                    paramName,\\n                  file,\\n                  fileName\\n                );\\n              }\\n            });\\n          }\\n        }\\n        options.data = formData;\\n      }\\n      // Blob reference is not needed anymore, free memory:\\n      options.blob = null;\\n    },\\n\\n    _initIframeSettings: function (options) {\\n      var targetHost = $('<a></a>').prop('href', options.url).prop('host');\\n      // Setting the dataType to iframe enables the iframe transport:\\n      options.dataType = 'iframe ' + (options.dataType || '');\\n      // The iframe transport accepts a serialized array as form data:\\n      options.formData = this._getFormData(options);\\n      // Add redirect url to form data on cross-domain uploads:\\n      if (options.redirect && targetHost && targetHost !== location.host) {\\n        options.formData.push({\\n          name: options.redirectParamName || 'redirect',\\n          value: options.redirect\\n        });\\n      }\\n    },\\n\\n    _initDataSettings: function (options) {\\n      if (this._isXHRUpload(options)) {\\n        if (!this._chunkedUpload(options, true)) {\\n          if (!options.data) {\\n            this._initXHRData(options);\\n          }\\n          this._initProgressListener(options);\\n        }\\n        if (options.postMessage) {\\n          // Setting the dataType to postmessage enables the\\n          // postMessage transport:\\n          options.dataType = 'postmessage ' + (options.dataType || '');\\n        }\\n      } else {\\n        this._initIframeSettings(options);\\n      }\\n    },\\n\\n    _getParamName: function (options) {\\n      var fileInput = $(options.fileInput),\\n        paramName = options.paramName;\\n      if (!paramName) {\\n        paramName = [];\\n        fileInput.each(function () {\\n          var input = $(this),\\n            name = input.prop('name') || 'files[]',\\n            i = (input.prop('files') || [1]).length;\\n          while (i) {\\n            paramName.push(name);\\n            i -= 1;\\n          }\\n        });\\n        if (!paramName.length) {\\n          paramName = [fileInput.prop('name') || 'files[]'];\\n        }\\n      } else if (!$.isArray(paramName)) {\\n        paramName = [paramName];\\n      }\\n      return paramName;\\n    },\\n\\n    _initFormSettings: function (options) {\\n      // Retrieve missing options from the input field and the\\n      // associated form, if available:\\n      if (!options.form || !options.form.length) {\\n        options.form = $(options.fileInput.prop('form'));\\n        // If the given file input doesn't have an associated form,\\n        // use the default widget file input's form:\\n        if (!options.form.length) {\\n          options.form = $(this.options.fileInput.prop('form'));\\n        }\\n      }\\n      options.paramName = this._getParamName(options);\\n      if (!options.url) {\\n        options.url = options.form.prop('action') || location.href;\\n      }\\n      // The HTTP request method must be \\\"POST\\\" or \\\"PUT\\\":\\n      options.type = (\\n        options.type ||\\n        ($.type(options.form.prop('method')) === 'string' &&\\n          options.form.prop('method')) ||\\n        ''\\n      ).toUpperCase();\\n      if (\\n        options.type !== 'POST' &&\\n        options.type !== 'PUT' &&\\n        options.type !== 'PATCH'\\n      ) {\\n        options.type = 'POST';\\n      }\\n      if (!options.formAcceptCharset) {\\n        options.formAcceptCharset = options.form.attr('accept-charset');\\n      }\\n    },\\n\\n    _getAJAXSettings: function (data) {\\n      var options = $.extend({}, this.options, data);\\n      this._initFormSettings(options);\\n      this._initDataSettings(options);\\n      return options;\\n    },\\n\\n    // jQuery 1.6 doesn't provide .state(),\\n    // while jQuery 1.8+ removed .isRejected() and .isResolved():\\n    _getDeferredState: function (deferred) {\\n      if (deferred.state) {\\n        return deferred.state();\\n      }\\n      if (deferred.isResolved()) {\\n        return 'resolved';\\n      }\\n      if (deferred.isRejected()) {\\n        return 'rejected';\\n      }\\n      return 'pending';\\n    },\\n\\n    // Maps jqXHR callbacks to the equivalent\\n    // methods of the given Promise object:\\n    _enhancePromise: function (promise) {\\n      promise.success = promise.done;\\n      promise.error = promise.fail;\\n      promise.complete = promise.always;\\n      return promise;\\n    },\\n\\n    // Creates and returns a Promise object enhanced with\\n    // the jqXHR methods abort, success, error and complete:\\n    _getXHRPromise: function (resolveOrReject, context, args) {\\n      var dfd = $.Deferred(),\\n        promise = dfd.promise();\\n      // eslint-disable-next-line no-param-reassign\\n      context = context || this.options.context || promise;\\n      if (resolveOrReject === true) {\\n        dfd.resolveWith(context, args);\\n      } else if (resolveOrReject === false) {\\n        dfd.rejectWith(context, args);\\n      }\\n      promise.abort = dfd.promise;\\n      return this._enhancePromise(promise);\\n    },\\n\\n    // Adds convenience methods to the data callback argument:\\n    _addConvenienceMethods: function (e, data) {\\n      var that = this,\\n        getPromise = function (args) {\\n          return $.Deferred().resolveWith(that, args).promise();\\n        };\\n      data.process = function (resolveFunc, rejectFunc) {\\n        if (resolveFunc || rejectFunc) {\\n          data._processQueue = this._processQueue = (this._processQueue ||\\n            getPromise([this]))\\n            [that._promisePipe](function () {\\n              if (data.errorThrown) {\\n                return $.Deferred().rejectWith(that, [data]).promise();\\n              }\\n              return getPromise(arguments);\\n            })\\n            [that._promisePipe](resolveFunc, rejectFunc);\\n        }\\n        return this._processQueue || getPromise([this]);\\n      };\\n      data.submit = function () {\\n        if (this.state() !== 'pending') {\\n          data.jqXHR = this.jqXHR =\\n            that._trigger(\\n              'submit',\\n              $.Event('submit', { delegatedEvent: e }),\\n              this\\n            ) !== false && that._onSend(e, this);\\n        }\\n        return this.jqXHR || that._getXHRPromise();\\n      };\\n      data.abort = function () {\\n        if (this.jqXHR) {\\n          return this.jqXHR.abort();\\n        }\\n        this.errorThrown = 'abort';\\n        that._trigger('fail', null, this);\\n        return that._getXHRPromise(false);\\n      };\\n      data.state = function () {\\n        if (this.jqXHR) {\\n          return that._getDeferredState(this.jqXHR);\\n        }\\n        if (this._processQueue) {\\n          return that._getDeferredState(this._processQueue);\\n        }\\n      };\\n      data.processing = function () {\\n        return (\\n          !this.jqXHR &&\\n          this._processQueue &&\\n          that._getDeferredState(this._processQueue) === 'pending'\\n        );\\n      };\\n      data.progress = function () {\\n        return this._progress;\\n      };\\n      data.response = function () {\\n        return this._response;\\n      };\\n    },\\n\\n    // Parses the Range header from the server response\\n    // and returns the uploaded bytes:\\n    _getUploadedBytes: function (jqXHR) {\\n      var range = jqXHR.getResponseHeader('Range'),\\n        parts = range && range.split('-'),\\n        upperBytesPos = parts && parts.length > 1 && parseInt(parts[1], 10);\\n      return upperBytesPos && upperBytesPos + 1;\\n    },\\n\\n    // Uploads a file in multiple, sequential requests\\n    // by splitting the file up in multiple blob chunks.\\n    // If the second parameter is true, only tests if the file\\n    // should be uploaded in chunks, but does not invoke any\\n    // upload requests:\\n    _chunkedUpload: function (options, testOnly) {\\n      options.uploadedBytes = options.uploadedBytes || 0;\\n      var that = this,\\n        file = options.files[0],\\n        fs = file.size,\\n        ub = options.uploadedBytes,\\n        mcs = options.maxChunkSize || fs,\\n        slice = this._blobSlice,\\n        dfd = $.Deferred(),\\n        promise = dfd.promise(),\\n        jqXHR,\\n        upload;\\n      if (\\n        !(\\n          this._isXHRUpload(options) &&\\n          slice &&\\n          (ub || ($.type(mcs) === 'function' ? mcs(options) : mcs) < fs)\\n        ) ||\\n        options.data\\n      ) {\\n        return false;\\n      }\\n      if (testOnly) {\\n        return true;\\n      }\\n      if (ub >= fs) {\\n        file.error = options.i18n('uploadedBytes');\\n        return this._getXHRPromise(false, options.context, [\\n          null,\\n          'error',\\n          file.error\\n        ]);\\n      }\\n      // The chunk upload method:\\n      upload = function () {\\n        // Clone the options object for each chunk upload:\\n        var o = $.extend({}, options),\\n          currentLoaded = o._progress.loaded;\\n        o.blob = slice.call(\\n          file,\\n          ub,\\n          ub + ($.type(mcs) === 'function' ? mcs(o) : mcs),\\n          file.type\\n        );\\n        // Store the current chunk size, as the blob itself\\n        // will be dereferenced after data processing:\\n        o.chunkSize = o.blob.size;\\n        // Expose the chunk bytes position range:\\n        o.contentRange =\\n          'bytes ' + ub + '-' + (ub + o.chunkSize - 1) + '/' + fs;\\n        // Trigger chunkbeforesend to allow form data to be updated for this chunk\\n        that._trigger('chunkbeforesend', null, o);\\n        // Process the upload data (the blob and potential form data):\\n        that._initXHRData(o);\\n        // Add progress listeners for this chunk upload:\\n        that._initProgressListener(o);\\n        jqXHR = (\\n          (that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||\\n          that._getXHRPromise(false, o.context)\\n        )\\n          .done(function (result, textStatus, jqXHR) {\\n            ub = that._getUploadedBytes(jqXHR) || ub + o.chunkSize;\\n            // Create a progress event if no final progress event\\n            // with loaded equaling total has been triggered\\n            // for this chunk:\\n            if (currentLoaded + o.chunkSize - o._progress.loaded) {\\n              that._onProgress(\\n                $.Event('progress', {\\n                  lengthComputable: true,\\n                  loaded: ub - o.uploadedBytes,\\n                  total: ub - o.uploadedBytes\\n                }),\\n                o\\n              );\\n            }\\n            options.uploadedBytes = o.uploadedBytes = ub;\\n            o.result = result;\\n            o.textStatus = textStatus;\\n            o.jqXHR = jqXHR;\\n            that._trigger('chunkdone', null, o);\\n            that._trigger('chunkalways', null, o);\\n            if (ub < fs) {\\n              // File upload not yet complete,\\n              // continue with the next chunk:\\n              upload();\\n            } else {\\n              dfd.resolveWith(o.context, [result, textStatus, jqXHR]);\\n            }\\n          })\\n          .fail(function (jqXHR, textStatus, errorThrown) {\\n            o.jqXHR = jqXHR;\\n            o.textStatus = textStatus;\\n            o.errorThrown = errorThrown;\\n            that._trigger('chunkfail', null, o);\\n            that._trigger('chunkalways', null, o);\\n            dfd.rejectWith(o.context, [jqXHR, textStatus, errorThrown]);\\n          })\\n          .always(function () {\\n            that._deinitProgressListener(o);\\n          });\\n      };\\n      this._enhancePromise(promise);\\n      promise.abort = function () {\\n        return jqXHR.abort();\\n      };\\n      upload();\\n      return promise;\\n    },\\n\\n    _beforeSend: function (e, data) {\\n      if (this._active === 0) {\\n        // the start callback is triggered when an upload starts\\n        // and no other uploads are currently running,\\n        // equivalent to the global ajaxStart event:\\n        this._trigger('start');\\n        // Set timer for global bitrate progress calculation:\\n        this._bitrateTimer = new this._BitrateTimer();\\n        // Reset the global progress values:\\n        this._progress.loaded = this._progress.total = 0;\\n        this._progress.bitrate = 0;\\n      }\\n      // Make sure the container objects for the .response() and\\n      // .progress() methods on the data object are available\\n      // and reset to their initial state:\\n      this._initResponseObject(data);\\n      this._initProgressObject(data);\\n      data._progress.loaded = data.loaded = data.uploadedBytes || 0;\\n      data._progress.total = data.total = this._getTotal(data.files) || 1;\\n      data._progress.bitrate = data.bitrate = 0;\\n      this._active += 1;\\n      // Initialize the global progress values:\\n      this._progress.loaded += data.loaded;\\n      this._progress.total += data.total;\\n    },\\n\\n    _onDone: function (result, textStatus, jqXHR, options) {\\n      var total = options._progress.total,\\n        response = options._response;\\n      if (options._progress.loaded < total) {\\n        // Create a progress event if no final progress event\\n        // with loaded equaling total has been triggered:\\n        this._onProgress(\\n          $.Event('progress', {\\n            lengthComputable: true,\\n            loaded: total,\\n            total: total\\n          }),\\n          options\\n        );\\n      }\\n      response.result = options.result = result;\\n      response.textStatus = options.textStatus = textStatus;\\n      response.jqXHR = options.jqXHR = jqXHR;\\n      this._trigger('done', null, options);\\n    },\\n\\n    _onFail: function (jqXHR, textStatus, errorThrown, options) {\\n      var response = options._response;\\n      if (options.recalculateProgress) {\\n        // Remove the failed (error or abort) file upload from\\n        // the global progress calculation:\\n        this._progress.loaded -= options._progress.loaded;\\n        this._progress.total -= options._progress.total;\\n      }\\n      response.jqXHR = options.jqXHR = jqXHR;\\n      response.textStatus = options.textStatus = textStatus;\\n      response.errorThrown = options.errorThrown = errorThrown;\\n      this._trigger('fail', null, options);\\n    },\\n\\n    _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {\\n      // jqXHRorResult, textStatus and jqXHRorError are added to the\\n      // options object via done and fail callbacks\\n      this._trigger('always', null, options);\\n    },\\n\\n    _onSend: function (e, data) {\\n      if (!data.submit) {\\n        this._addConvenienceMethods(e, data);\\n      }\\n      var that = this,\\n        jqXHR,\\n        aborted,\\n        slot,\\n        pipe,\\n        options = that._getAJAXSettings(data),\\n        send = function () {\\n          that._sending += 1;\\n          // Set timer for bitrate progress calculation:\\n          options._bitrateTimer = new that._BitrateTimer();\\n          jqXHR =\\n            jqXHR ||\\n            (\\n              ((aborted ||\\n                that._trigger(\\n                  'send',\\n                  $.Event('send', { delegatedEvent: e }),\\n                  options\\n                ) === false) &&\\n                that._getXHRPromise(false, options.context, aborted)) ||\\n              that._chunkedUpload(options) ||\\n              $.ajax(options)\\n            )\\n              .done(function (result, textStatus, jqXHR) {\\n                that._onDone(result, textStatus, jqXHR, options);\\n              })\\n              .fail(function (jqXHR, textStatus, errorThrown) {\\n                that._onFail(jqXHR, textStatus, errorThrown, options);\\n              })\\n              .always(function (jqXHRorResult, textStatus, jqXHRorError) {\\n                that._deinitProgressListener(options);\\n                that._onAlways(\\n                  jqXHRorResult,\\n                  textStatus,\\n                  jqXHRorError,\\n                  options\\n                );\\n                that._sending -= 1;\\n                that._active -= 1;\\n                if (\\n                  options.limitConcurrentUploads &&\\n                  options.limitConcurrentUploads > that._sending\\n                ) {\\n                  // Start the next queued upload,\\n                  // that has not been aborted:\\n                  var nextSlot = that._slots.shift();\\n                  while (nextSlot) {\\n                    if (that._getDeferredState(nextSlot) === 'pending') {\\n                      nextSlot.resolve();\\n                      break;\\n                    }\\n                    nextSlot = that._slots.shift();\\n                  }\\n                }\\n                if (that._active === 0) {\\n                  // The stop callback is triggered when all uploads have\\n                  // been completed, equivalent to the global ajaxStop event:\\n                  that._trigger('stop');\\n                }\\n              });\\n          return jqXHR;\\n        };\\n      this._beforeSend(e, options);\\n      if (\\n        this.options.sequentialUploads ||\\n        (this.options.limitConcurrentUploads &&\\n          this.options.limitConcurrentUploads <= this._sending)\\n      ) {\\n        if (this.options.limitConcurrentUploads > 1) {\\n          slot = $.Deferred();\\n          this._slots.push(slot);\\n          pipe = slot[that._promisePipe](send);\\n        } else {\\n          this._sequence = this._sequence[that._promisePipe](send, send);\\n          pipe = this._sequence;\\n        }\\n        // Return the piped Promise object, enhanced with an abort method,\\n        // which is delegated to the jqXHR object of the current upload,\\n        // and jqXHR callbacks mapped to the equivalent Promise methods:\\n        pipe.abort = function () {\\n          aborted = [undefined, 'abort', 'abort'];\\n          if (!jqXHR) {\\n            if (slot) {\\n              slot.rejectWith(options.context, aborted);\\n            }\\n            return send();\\n          }\\n          return jqXHR.abort();\\n        };\\n        return this._enhancePromise(pipe);\\n      }\\n      return send();\\n    },\\n\\n    _onAdd: function (e, data) {\\n      var that = this,\\n        result = true,\\n        options = $.extend({}, this.options, data),\\n        files = data.files,\\n        filesLength = files.length,\\n        limit = options.limitMultiFileUploads,\\n        limitSize = options.limitMultiFileUploadSize,\\n        overhead = options.limitMultiFileUploadSizeOverhead,\\n        batchSize = 0,\\n        paramName = this._getParamName(options),\\n        paramNameSet,\\n        paramNameSlice,\\n        fileSet,\\n        i,\\n        j = 0;\\n      if (!filesLength) {\\n        return false;\\n      }\\n      if (limitSize && files[0].size === undefined) {\\n        limitSize = undefined;\\n      }\\n      if (\\n        !(options.singleFileUploads || limit || limitSize) ||\\n        !this._isXHRUpload(options)\\n      ) {\\n        fileSet = [files];\\n        paramNameSet = [paramName];\\n      } else if (!(options.singleFileUploads || limitSize) && limit) {\\n        fileSet = [];\\n        paramNameSet = [];\\n        for (i = 0; i < filesLength; i += limit) {\\n          fileSet.push(files.slice(i, i + limit));\\n          paramNameSlice = paramName.slice(i, i + limit);\\n          if (!paramNameSlice.length) {\\n            paramNameSlice = paramName;\\n          }\\n          paramNameSet.push(paramNameSlice);\\n        }\\n      } else if (!options.singleFileUploads && limitSize) {\\n        fileSet = [];\\n        paramNameSet = [];\\n        for (i = 0; i < filesLength; i = i + 1) {\\n          batchSize += files[i].size + overhead;\\n          if (\\n            i + 1 === filesLength ||\\n            batchSize + files[i + 1].size + overhead > limitSize ||\\n            (limit && i + 1 - j >= limit)\\n          ) {\\n            fileSet.push(files.slice(j, i + 1));\\n            paramNameSlice = paramName.slice(j, i + 1);\\n            if (!paramNameSlice.length) {\\n              paramNameSlice = paramName;\\n            }\\n            paramNameSet.push(paramNameSlice);\\n            j = i + 1;\\n            batchSize = 0;\\n          }\\n        }\\n      } else {\\n        paramNameSet = paramName;\\n      }\\n      data.originalFiles = files;\\n      $.each(fileSet || files, function (index, element) {\\n        var newData = $.extend({}, data);\\n        newData.files = fileSet ? element : [element];\\n        newData.paramName = paramNameSet[index];\\n        that._initResponseObject(newData);\\n        that._initProgressObject(newData);\\n        that._addConvenienceMethods(e, newData);\\n        result = that._trigger(\\n          'add',\\n          $.Event('add', { delegatedEvent: e }),\\n          newData\\n        );\\n        return result;\\n      });\\n      return result;\\n    },\\n\\n    _replaceFileInput: function (data) {\\n      var input = data.fileInput,\\n        inputClone = input.clone(true),\\n        restoreFocus = input.is(document.activeElement);\\n      // Add a reference for the new cloned file input to the data argument:\\n      data.fileInputClone = inputClone;\\n      $('<form></form>').append(inputClone)[0].reset();\\n      // Detaching allows to insert the fileInput on another form\\n      // without loosing the file input value:\\n      input.after(inputClone).detach();\\n      // If the fileInput had focus before it was detached,\\n      // restore focus to the inputClone.\\n      if (restoreFocus) {\\n        inputClone.trigger('focus');\\n      }\\n      // Avoid memory leaks with the detached file input:\\n      $.cleanData(input.off('remove'));\\n      // Replace the original file input element in the fileInput\\n      // elements set with the clone, which has been copied including\\n      // event handlers:\\n      this.options.fileInput = this.options.fileInput.map(function (i, el) {\\n        if (el === input[0]) {\\n          return inputClone[0];\\n        }\\n        return el;\\n      });\\n      // If the widget has been initialized on the file input itself,\\n      // override this.element with the file input clone:\\n      if (input[0] === this.element[0]) {\\n        this.element = inputClone;\\n      }\\n    },\\n\\n    _handleFileTreeEntry: function (entry, path) {\\n      var that = this,\\n        dfd = $.Deferred(),\\n        entries = [],\\n        dirReader,\\n        errorHandler = function (e) {\\n          if (e && !e.entry) {\\n            e.entry = entry;\\n          }\\n          // Since $.when returns immediately if one\\n          // Deferred is rejected, we use resolve instead.\\n          // This allows valid files and invalid items\\n          // to be returned together in one set:\\n          dfd.resolve([e]);\\n        },\\n        successHandler = function (entries) {\\n          that\\n            ._handleFileTreeEntries(entries, path + entry.name + '/')\\n            .done(function (files) {\\n              dfd.resolve(files);\\n            })\\n            .fail(errorHandler);\\n        },\\n        readEntries = function () {\\n          dirReader.readEntries(function (results) {\\n            if (!results.length) {\\n              successHandler(entries);\\n            } else {\\n              entries = entries.concat(results);\\n              readEntries();\\n            }\\n          }, errorHandler);\\n        };\\n      // eslint-disable-next-line no-param-reassign\\n      path = path || '';\\n      if (entry.isFile) {\\n        if (entry._file) {\\n          // Workaround for Chrome bug #149735\\n          entry._file.relativePath = path;\\n          dfd.resolve(entry._file);\\n        } else {\\n          entry.file(function (file) {\\n            file.relativePath = path;\\n            dfd.resolve(file);\\n          }, errorHandler);\\n        }\\n      } else if (entry.isDirectory) {\\n        dirReader = entry.createReader();\\n        readEntries();\\n      } else {\\n        // Return an empty list for file system items\\n        // other than files or directories:\\n        dfd.resolve([]);\\n      }\\n      return dfd.promise();\\n    },\\n\\n    _handleFileTreeEntries: function (entries, path) {\\n      var that = this;\\n      return $.when\\n        .apply(\\n          $,\\n          $.map(entries, function (entry) {\\n            return that._handleFileTreeEntry(entry, path);\\n          })\\n        )\\n        [this._promisePipe](function () {\\n          return Array.prototype.concat.apply([], arguments);\\n        });\\n    },\\n\\n    _getDroppedFiles: function (dataTransfer) {\\n      // eslint-disable-next-line no-param-reassign\\n      dataTransfer = dataTransfer || {};\\n      var items = dataTransfer.items;\\n      if (\\n        items &&\\n        items.length &&\\n        (items[0].webkitGetAsEntry || items[0].getAsEntry)\\n      ) {\\n        return this._handleFileTreeEntries(\\n          $.map(items, function (item) {\\n            var entry;\\n            if (item.webkitGetAsEntry) {\\n              entry = item.webkitGetAsEntry();\\n              if (entry) {\\n                // Workaround for Chrome bug #149735:\\n                entry._file = item.getAsFile();\\n              }\\n              return entry;\\n            }\\n            return item.getAsEntry();\\n          })\\n        );\\n      }\\n      return $.Deferred().resolve($.makeArray(dataTransfer.files)).promise();\\n    },\\n\\n    _getSingleFileInputFiles: function (fileInput) {\\n      // eslint-disable-next-line no-param-reassign\\n      fileInput = $(fileInput);\\n      var entries =\\n          fileInput.prop('webkitEntries') || fileInput.prop('entries'),\\n        files,\\n        value;\\n      if (entries && entries.length) {\\n        return this._handleFileTreeEntries(entries);\\n      }\\n      files = $.makeArray(fileInput.prop('files'));\\n      if (!files.length) {\\n        value = fileInput.prop('value');\\n        if (!value) {\\n          return $.Deferred().resolve([]).promise();\\n        }\\n        // If the files property is not available, the browser does not\\n        // support the File API and we add a pseudo File object with\\n        // the input value as name with path information removed:\\n        files = [{ name: value.replace(/^.*\\\\\\\\/, '') }];\\n      } else if (files[0].name === undefined && files[0].fileName) {\\n        // File normalization for Safari 4 and Firefox 3:\\n        $.each(files, function (index, file) {\\n          file.name = file.fileName;\\n          file.size = file.fileSize;\\n        });\\n      }\\n      return $.Deferred().resolve(files).promise();\\n    },\\n\\n    _getFileInputFiles: function (fileInput) {\\n      if (!(fileInput instanceof $) || fileInput.length === 1) {\\n        return this._getSingleFileInputFiles(fileInput);\\n      }\\n      return $.when\\n        .apply($, $.map(fileInput, this._getSingleFileInputFiles))\\n        [this._promisePipe](function () {\\n          return Array.prototype.concat.apply([], arguments);\\n        });\\n    },\\n\\n    _onChange: function (e) {\\n      var that = this,\\n        data = {\\n          fileInput: $(e.target),\\n          form: $(e.target.form)\\n        };\\n      this._getFileInputFiles(data.fileInput).always(function (files) {\\n        data.files = files;\\n        if (that.options.replaceFileInput) {\\n          that._replaceFileInput(data);\\n        }\\n        if (\\n          that._trigger(\\n            'change',\\n            $.Event('change', { delegatedEvent: e }),\\n            data\\n          ) !== false\\n        ) {\\n          that._onAdd(e, data);\\n        }\\n      });\\n    },\\n\\n    _onPaste: function (e) {\\n      var items =\\n          e.originalEvent &&\\n          e.originalEvent.clipboardData &&\\n          e.originalEvent.clipboardData.items,\\n        data = { files: [] };\\n      if (items && items.length) {\\n        $.each(items, function (index, item) {\\n          var file = item.getAsFile && item.getAsFile();\\n          if (file) {\\n            data.files.push(file);\\n          }\\n        });\\n        if (\\n          this._trigger(\\n            'paste',\\n            $.Event('paste', { delegatedEvent: e }),\\n            data\\n          ) !== false\\n        ) {\\n          this._onAdd(e, data);\\n        }\\n      }\\n    },\\n\\n    _onDrop: function (e) {\\n      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\\n      var that = this,\\n        dataTransfer = e.dataTransfer,\\n        data = {};\\n      if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\\n        e.preventDefault();\\n        this._getDroppedFiles(dataTransfer).always(function (files) {\\n          data.files = files;\\n          if (\\n            that._trigger(\\n              'drop',\\n              $.Event('drop', { delegatedEvent: e }),\\n              data\\n            ) !== false\\n          ) {\\n            that._onAdd(e, data);\\n          }\\n        });\\n      }\\n    },\\n\\n    _onDragOver: getDragHandler('dragover'),\\n\\n    _onDragEnter: getDragHandler('dragenter'),\\n\\n    _onDragLeave: getDragHandler('dragleave'),\\n\\n    _initEventHandlers: function () {\\n      if (this._isXHRUpload(this.options)) {\\n        this._on(this.options.dropZone, {\\n          dragover: this._onDragOver,\\n          drop: this._onDrop,\\n          // event.preventDefault() on dragenter is required for IE10+:\\n          dragenter: this._onDragEnter,\\n          // dragleave is not required, but added for completeness:\\n          dragleave: this._onDragLeave\\n        });\\n        this._on(this.options.pasteZone, {\\n          paste: this._onPaste\\n        });\\n      }\\n      if ($.support.fileInput) {\\n        this._on(this.options.fileInput, {\\n          change: this._onChange\\n        });\\n      }\\n    },\\n\\n    _destroyEventHandlers: function () {\\n      this._off(this.options.dropZone, 'dragenter dragleave dragover drop');\\n      this._off(this.options.pasteZone, 'paste');\\n      this._off(this.options.fileInput, 'change');\\n    },\\n\\n    _destroy: function () {\\n      this._destroyEventHandlers();\\n    },\\n\\n    _setOption: function (key, value) {\\n      var reinit = $.inArray(key, this._specialOptions) !== -1;\\n      if (reinit) {\\n        this._destroyEventHandlers();\\n      }\\n      this._super(key, value);\\n      if (reinit) {\\n        this._initSpecialOptions();\\n        this._initEventHandlers();\\n      }\\n    },\\n\\n    _initSpecialOptions: function () {\\n      var options = this.options;\\n      if (options.fileInput === undefined) {\\n        options.fileInput = this.element.is('input[type=\\\"file\\\"]')\\n          ? this.element\\n          : this.element.find('input[type=\\\"file\\\"]');\\n      } else if (!(options.fileInput instanceof $)) {\\n        options.fileInput = $(options.fileInput);\\n      }\\n      if (!(options.dropZone instanceof $)) {\\n        options.dropZone = $(options.dropZone);\\n      }\\n      if (!(options.pasteZone instanceof $)) {\\n        options.pasteZone = $(options.pasteZone);\\n      }\\n    },\\n\\n    _getRegExp: function (str) {\\n      var parts = str.split('/'),\\n        modifiers = parts.pop();\\n      parts.shift();\\n      return new RegExp(parts.join('/'), modifiers);\\n    },\\n\\n    _isRegExpOption: function (key, value) {\\n      return (\\n        key !== 'url' &&\\n        $.type(value) === 'string' &&\\n        /^\\\\/.*\\\\/[igm]{0,3}$/.test(value)\\n      );\\n    },\\n\\n    _initDataAttributes: function () {\\n      var that = this,\\n        options = this.options,\\n        data = this.element.data();\\n      // Initialize options set via HTML5 data-attributes:\\n      $.each(this.element[0].attributes, function (index, attr) {\\n        var key = attr.name.toLowerCase(),\\n          value;\\n        if (/^data-/.test(key)) {\\n          // Convert hyphen-ated key to camelCase:\\n          key = key.slice(5).replace(/-[a-z]/g, function (str) {\\n            return str.charAt(1).toUpperCase();\\n          });\\n          value = data[key];\\n          if (that._isRegExpOption(key, value)) {\\n            value = that._getRegExp(value);\\n          }\\n          options[key] = value;\\n        }\\n      });\\n    },\\n\\n    _create: function () {\\n      this._initDataAttributes();\\n      this._initSpecialOptions();\\n      this._slots = [];\\n      this._sequence = this._getXHRPromise(true);\\n      this._sending = this._active = 0;\\n      this._initProgressObject(this);\\n      this._initEventHandlers();\\n    },\\n\\n    // This method is exposed to the widget API and allows to query\\n    // the number of active uploads:\\n    active: function () {\\n      return this._active;\\n    },\\n\\n    // This method is exposed to the widget API and allows to query\\n    // the widget upload progress.\\n    // It returns an object with loaded, total and bitrate properties\\n    // for the running uploads:\\n    progress: function () {\\n      return this._progress;\\n    },\\n\\n    // This method is exposed to the widget API and allows adding files\\n    // using the fileupload API. The data parameter accepts an object which\\n    // must have a files property and can contain additional options:\\n    // .fileupload('add', {files: filesList});\\n    add: function (data) {\\n      var that = this;\\n      if (!data || this.options.disabled) {\\n        return;\\n      }\\n      if (data.fileInput && !data.files) {\\n        this._getFileInputFiles(data.fileInput).always(function (files) {\\n          data.files = files;\\n          that._onAdd(null, data);\\n        });\\n      } else {\\n        data.files = $.makeArray(data.files);\\n        this._onAdd(null, data);\\n      }\\n    },\\n\\n    // This method is exposed to the widget API and allows sending files\\n    // using the fileupload API. The data parameter accepts an object which\\n    // must have a files or fileInput property and can contain additional options:\\n    // .fileupload('send', {files: filesList});\\n    // The method returns a Promise object for the file upload call.\\n    send: function (data) {\\n      if (data && !this.options.disabled) {\\n        if (data.fileInput && !data.files) {\\n          var that = this,\\n            dfd = $.Deferred(),\\n            promise = dfd.promise(),\\n            jqXHR,\\n            aborted;\\n          promise.abort = function () {\\n            aborted = true;\\n            if (jqXHR) {\\n              return jqXHR.abort();\\n            }\\n            dfd.reject(null, 'abort', 'abort');\\n            return promise;\\n          };\\n          this._getFileInputFiles(data.fileInput).always(function (files) {\\n            if (aborted) {\\n              return;\\n            }\\n            if (!files.length) {\\n              dfd.reject();\\n              return;\\n            }\\n            data.files = files;\\n            jqXHR = that._onSend(null, data);\\n            jqXHR.then(\\n              function (result, textStatus, jqXHR) {\\n                dfd.resolve(result, textStatus, jqXHR);\\n              },\\n              function (jqXHR, textStatus, errorThrown) {\\n                dfd.reject(jqXHR, textStatus, errorThrown);\\n              }\\n            );\\n          });\\n          return this._enhancePromise(promise);\\n        }\\n        data.files = $.makeArray(data.files);\\n        if (data.files.length) {\\n          return this._onSend(null, data);\\n        }\\n      }\\n      return this._getXHRPromise(false, data && data.context);\\n    }\\n  });\\n});\\n\"","module.exports = \"/*\\n * jQuery Iframe Transport Plugin\\n * https://github.com/blueimp/jQuery-File-Upload\\n *\\n * Copyright 2011, Sebastian Tschan\\n * https://blueimp.net\\n *\\n * Licensed under the MIT license:\\n * https://opensource.org/licenses/MIT\\n */\\n\\n/* global define, require */\\n\\n(function (factory) {\\n  'use strict';\\n  if (typeof define === 'function' && define.amd) {\\n    // Register as an anonymous AMD module:\\n    define(['jquery'], factory);\\n  } else if (typeof exports === 'object') {\\n    // Node/CommonJS:\\n    factory(require('jquery'));\\n  } else {\\n    // Browser globals:\\n    factory(window.jQuery);\\n  }\\n})(function ($) {\\n  'use strict';\\n\\n  // Helper variable to create unique names for the transport iframes:\\n  var counter = 0,\\n    jsonAPI = $,\\n    jsonParse = 'parseJSON';\\n\\n  if ('JSON' in window && 'parse' in JSON) {\\n    jsonAPI = JSON;\\n    jsonParse = 'parse';\\n  }\\n\\n  // The iframe transport accepts four additional options:\\n  // options.fileInput: a jQuery collection of file input fields\\n  // options.paramName: the parameter name for the file form data,\\n  //  overrides the name property of the file input field(s),\\n  //  can be a string or an array of strings.\\n  // options.formData: an array of objects with name and value properties,\\n  //  equivalent to the return data of .serializeArray(), e.g.:\\n  //  [{name: 'a', value: 1}, {name: 'b', value: 2}]\\n  // options.initialIframeSrc: the URL of the initial iframe src,\\n  //  by default set to \\\"javascript:false;\\\"\\n  $.ajaxTransport('iframe', function (options) {\\n    if (options.async) {\\n      // javascript:false as initial iframe src\\n      // prevents warning popups on HTTPS in IE6:\\n      // eslint-disable-next-line no-script-url\\n      var initialIframeSrc = options.initialIframeSrc || 'javascript:false;',\\n        form,\\n        iframe,\\n        addParamChar;\\n      return {\\n        send: function (_, completeCallback) {\\n          form = $('<form style=\\\"display:none;\\\"></form>');\\n          form.attr('accept-charset', options.formAcceptCharset);\\n          addParamChar = /\\\\?/.test(options.url) ? '&' : '?';\\n          // XDomainRequest only supports GET and POST:\\n          if (options.type === 'DELETE') {\\n            options.url = options.url + addParamChar + '_method=DELETE';\\n            options.type = 'POST';\\n          } else if (options.type === 'PUT') {\\n            options.url = options.url + addParamChar + '_method=PUT';\\n            options.type = 'POST';\\n          } else if (options.type === 'PATCH') {\\n            options.url = options.url + addParamChar + '_method=PATCH';\\n            options.type = 'POST';\\n          }\\n          // IE versions below IE8 cannot set the name property of\\n          // elements that have already been added to the DOM,\\n          // so we set the name along with the iframe HTML markup:\\n          counter += 1;\\n          iframe = $(\\n            '<iframe src=\\\"' +\\n              initialIframeSrc +\\n              '\\\" name=\\\"iframe-transport-' +\\n              counter +\\n              '\\\"></iframe>'\\n          ).on('load', function () {\\n            var fileInputClones,\\n              paramNames = $.isArray(options.paramName)\\n                ? options.paramName\\n                : [options.paramName];\\n            iframe.off('load').on('load', function () {\\n              var response;\\n              // Wrap in a try/catch block to catch exceptions thrown\\n              // when trying to access cross-domain iframe contents:\\n              try {\\n                response = iframe.contents();\\n                // Google Chrome and Firefox do not throw an\\n                // exception when calling iframe.contents() on\\n                // cross-domain requests, so we unify the response:\\n                if (!response.length || !response[0].firstChild) {\\n                  throw new Error();\\n                }\\n              } catch (e) {\\n                response = undefined;\\n              }\\n              // The complete callback returns the\\n              // iframe content document as response object:\\n              completeCallback(200, 'success', { iframe: response });\\n              // Fix for IE endless progress bar activity bug\\n              // (happens on form submits to iframe targets):\\n              $('<iframe src=\\\"' + initialIframeSrc + '\\\"></iframe>').appendTo(\\n                form\\n              );\\n              window.setTimeout(function () {\\n                // Removing the form in a setTimeout call\\n                // allows Chrome's developer tools to display\\n                // the response result\\n                form.remove();\\n              }, 0);\\n            });\\n            form\\n              .prop('target', iframe.prop('name'))\\n              .prop('action', options.url)\\n              .prop('method', options.type);\\n            if (options.formData) {\\n              $.each(options.formData, function (index, field) {\\n                $('<input type=\\\"hidden\\\"/>')\\n                  .prop('name', field.name)\\n                  .val(field.value)\\n                  .appendTo(form);\\n              });\\n            }\\n            if (\\n              options.fileInput &&\\n              options.fileInput.length &&\\n              options.type === 'POST'\\n            ) {\\n              fileInputClones = options.fileInput.clone();\\n              // Insert a clone for each file input field:\\n              options.fileInput.after(function (index) {\\n                return fileInputClones[index];\\n              });\\n              if (options.paramName) {\\n                options.fileInput.each(function (index) {\\n                  $(this).prop('name', paramNames[index] || options.paramName);\\n                });\\n              }\\n              // Appending the file input fields to the hidden form\\n              // removes them from their original location:\\n              form\\n                .append(options.fileInput)\\n                .prop('enctype', 'multipart/form-data')\\n                // enctype must be set as encoding for IE:\\n                .prop('encoding', 'multipart/form-data');\\n              // Remove the HTML5 form attribute from the input(s):\\n              options.fileInput.removeAttr('form');\\n            }\\n            window.setTimeout(function () {\\n              // Submitting the form in a setTimeout call fixes an issue with\\n              // Safari 13 not triggering the iframe load event after resetting\\n              // the load event handler, see also:\\n              // https://github.com/blueimp/jQuery-File-Upload/issues/3633\\n              form.submit();\\n              // Insert the file input fields at their original location\\n              // by replacing the clones with the originals:\\n              if (fileInputClones && fileInputClones.length) {\\n                options.fileInput.each(function (index, input) {\\n                  var clone = $(fileInputClones[index]);\\n                  // Restore the original name and form properties:\\n                  $(input)\\n                    .prop('name', clone.prop('name'))\\n                    .attr('form', clone.attr('form'));\\n                  clone.replaceWith(input);\\n                });\\n              }\\n            }, 0);\\n          });\\n          form.append(iframe).appendTo(document.body);\\n        },\\n        abort: function () {\\n          if (iframe) {\\n            // javascript:false as iframe src aborts the request\\n            // and prevents warning popups on HTTPS in IE6.\\n            iframe.off('load').prop('src', initialIframeSrc);\\n          }\\n          if (form) {\\n            form.remove();\\n          }\\n        }\\n      };\\n    }\\n  });\\n\\n  // The iframe transport returns the iframe content document as response.\\n  // The following adds converters from iframe to text, json, html, xml\\n  // and script.\\n  // Please note that the Content-Type for JSON responses has to be text/plain\\n  // or text/html, if the browser doesn't include application/json in the\\n  // Accept header, else IE will show a download dialog.\\n  // The Content-Type for XML responses on the other hand has to be always\\n  // application/xml or text/xml, so IE properly parses the XML response.\\n  // See also\\n  // https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation\\n  $.ajaxSetup({\\n    converters: {\\n      'iframe text': function (iframe) {\\n        return iframe && $(iframe[0].body).text();\\n      },\\n      'iframe json': function (iframe) {\\n        return iframe && jsonAPI[jsonParse]($(iframe[0].body).text());\\n      },\\n      'iframe html': function (iframe) {\\n        return iframe && $(iframe[0].body).html();\\n      },\\n      'iframe xml': function (iframe) {\\n        var xmlDoc = iframe && iframe[0];\\n        return xmlDoc && $.isXMLDoc(xmlDoc)\\n          ? xmlDoc\\n          : $.parseXML(\\n              (xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml) ||\\n                $(xmlDoc.body).html()\\n            );\\n      },\\n      'iframe script': function (iframe) {\\n        return iframe && $.globalEval($(iframe[0].body).text());\\n      }\\n    }\\n  });\\n});\\n\"","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== \"undefined\")\n\t\t&& (console.error || console.log)(\"[Script Loader]\", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== \"undefined\" && typeof addEventListener === \"undefined\";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== \"undefined\" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== \"undefined\") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog(\"EvalError: No eval function available\");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n","require(\"!!/tmp/glpi-9.5.13/glpi/node_modules/script-loader/addScript.js\")(require(\"!!/tmp/glpi-9.5.13/glpi/node_modules/raw-loader/index.js!/tmp/glpi-9.5.13/glpi/node_modules/strip-sourcemap-loader/index.js!/tmp/glpi-9.5.13/glpi/vendor/blueimp/jquery-file-upload/js/jquery.fileupload.js\"))","require(\"!!/tmp/glpi-9.5.13/glpi/node_modules/script-loader/addScript.js\")(require(\"!!/tmp/glpi-9.5.13/glpi/node_modules/raw-loader/index.js!/tmp/glpi-9.5.13/glpi/node_modules/strip-sourcemap-loader/index.js!/tmp/glpi-9.5.13/glpi/vendor/blueimp/jquery-file-upload/js/jquery.iframe-transport.js\"))","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2022 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\n// jQuery File Upload plugin\nrequire('../../vendor/blueimp/jquery-file-upload/js/jquery.fileupload');\nrequire('../../vendor/blueimp/jquery-file-upload/js/jquery.iframe-transport');\n"],"names":[],"sourceRoot":""}